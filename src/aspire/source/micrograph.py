import numpy as np

from aspire.image import Image
from aspire.source import Simulation
from aspire.source.image import _ImageAccessor


class MicrographSource:
    def __init__(
        self,
        simulation,
        micrograph_size=4096,
        micrograph_count=1,
        particles_per_micrograph=10,
        seed=None,
        noise_adder=None,
        boundary=None,
        interparticle_distance=None,
    ):
        """
        A cryo-EM MicrographSource object that supplies micrographs.

        dtype and particle_box_size are inferred from simulation

        :param simulation: Simulation instance
        :param micrograph_size: Size of micrograph
        :param micrograph_count: Number of micrographs to generate (integer)
        :param particles_per_micrograph: The amount of particles generated for each micrograph
        :param seed: Random seed
        :param noise_adder: Optionally append instance of NoiseAdder to generation pipeline
        :param boundary: Optionally set boundaries for particle centers. Defaults to particle_box_size // 2, positive values move the boundary inward
        :param interparticle_distance: Optionally set minimum distance between particle centers. Defaults to particle_box_size * sqrt(2) to avoid collisions
        :return: A MicrographSource object
        """
        if not isinstance(simulation, Simulation):
            raise TypeError("Simulation should be of type Simulation")
        self.simulation = simulation

        self.seed = seed
        np.random.seed(self.seed)

        self.micrograph_size = micrograph_size
        self.micrograph_count = micrograph_count

        # Check if particle count times micrograph count <= simulation.n
        if particles_per_micrograph * micrograph_count > simulation.n:
            raise ValueError(
                "The particle count times micrograph count must be less than or equal to the number of images generated by the simulation (particles_per_micrograph * micrograph_count <= simulation.n)"
            )
        if simulation.L > micrograph_size:
            raise ValueError(
                "The micrograph size must be larger or equal to the simulation's image size."
            )

        self.particle_box_size = simulation.L
        self.particles_per_micrograph = particles_per_micrograph
        self.total_particle_count = (
            self.micrograph_count * self.particles_per_micrograph
        )
        self.dtype = simulation.dtype

        self.noise_adder = noise_adder

        if boundary is None:
            self.boundary = self.particle_box_size // 2
        else:
            if (
                boundary < (0 - self.particle_box_size // 2)
                or boundary > self.particle_box_size
            ):
                raise RuntimeError("Illegal boundary value.")
            self.boundary = boundary

        if interparticle_distance is None:
            self.interparticle_distance = np.sqrt(2) * self.particle_box_size
        else:
            self.interparticle_distance = interparticle_distance

        self.centers = np.zeros(
            (self.micrograph_count, self.particles_per_micrograph, 2), dtype=int
        )
        for i in range(self.micrograph_count):
            self.centers[i] = self._create_centers()

        self._clean_micrographs_accessor = _ImageAccessor(
            self._clean_micrographs, self.micrograph_count
        )
        self._micrographs_accessor = _ImageAccessor(
            self._micrographs, self.micrograph_count
        )

        self.images = _ImageAccessor(self._images, self.total_particle_count)

    def not_colliding(self, x1, y1, x2, y2, distance):
        return np.hypot(x1 - x2, y1 - y2) > distance

    def _create_centers(self):
        # initilize root2 for calculating sqrt(2) for Euclidean distance, and max_counts for attempts at randomizing points
        max_counts = 2500

        centers = np.ones((self.particles_per_micrograph, 2)) * -9999
        for i in range(self.particles_per_micrograph):
            # Initialize center coordinates and attempt count
            center_x, center_y, count = 0, 0, 0
            while count < max_counts:
                # Generate random coordinate within bounds
                center_x, center_y = self._generate_center()

                good_center = True
                for j in range(i):
                    if not self.not_colliding(
                        centers[j][0],
                        centers[j][1],
                        center_x,
                        center_y,
                        self.interparticle_distance,
                    ) or not self._in_boundary(center_x, center_y):
                        good_center = False

                # If there are no collisions or collisions are allowed, add new center and increase center count
                if good_center:
                    centers[i] = np.array([center_x, center_y])
                    count += max_counts
                count += 1
        # Check for zeroes
        zero_count = 0
        for center in centers:
            if center[0] == -9999 and center[1] == -9999:
                zero_count += 1
        if zero_count > 0:
            raise RuntimeError("Not enough centers generated.")
        return centers

    def _generate_center(self):
        parity = (self.boundary + 1) % 2
        x = (
            (self.micrograph_size - 2 * self.boundary - parity) * np.random.rand()
            + self.boundary
            + parity
        )
        y = (
            (self.micrograph_size - 2 * self.boundary - parity) * np.random.rand()
            + self.boundary
            + parity
        )
        return (int(x), int(y))

    def _in_boundary(self, x, y):
        return (
            x - self.particle_box_size // 2 > self.boundary
            and x + self.particle_box_size // 2 < self.micrograph_size - self.boundary
            and y - self.particle_box_size // 2 > self.boundary
            and y + self.particle_box_size // 2 < self.micrograph_size - self.boundary
        )

    def __len__(self):
        """ """
        return self.micrograph_count

    @property
    def clean_micrographs(self):
        return self._clean_micrographs_accessor

    @property
    def micrographs(self):
        return self._micrographs_accessor

    def _micrographs(self, indices):
        micrographs = self._clean_micrographs(indices)
        if self.noise_adder:
            micrographs = self.noise_adder.forward(micrographs)
        return micrographs

    def _clean_micrographs(self, indices):
        # Initialize empty micrograph
        n_micrographs = len(indices)
        clean_micrograph = np.zeros(
            (n_micrographs, self.micrograph_size, self.micrograph_size),
            dtype=self.dtype,
        )
        pad = self.particle_box_size
        clean_micrograph = np.pad(
            clean_micrograph,
            ((0, 0), (pad, pad), (pad, pad)),
            "constant",
            constant_values=(0),
        )
        # Get centers
        parity = self.particle_box_size % 2
        for m in range(n_micrographs):
            global_id = indices[m]
            image = self.simulation.clean_images[self.get_particle(global_id)]
            centers = self.centers[global_id]
            x_lefts = centers[:, 0] - self.particle_box_size // 2 + pad
            x_rights = centers[:, 0] + self.particle_box_size // 2 + parity + pad
            y_lefts = centers[:, 1] - self.particle_box_size // 2 + pad
            y_rights = centers[:, 1] + self.particle_box_size // 2 + parity + pad
            for p in range(self.particles_per_micrograph):
                clean_micrograph[m][
                    x_lefts[p] : x_rights[p], y_lefts[p] : y_rights[p]
                ] = (
                    clean_micrograph[m][
                        x_lefts[p] : x_rights[p], y_lefts[p] : y_rights[p]
                    ]
                    - image[p]
                )
        clean_micrograph = clean_micrograph[
            :,
            pad : self.micrograph_size + parity + pad,
            pad : self.micrograph_size + parity + pad,
        ]
        return Image(clean_micrograph)

    def _images(self, indices):
        return self.simulation.images[indices].asnumpy()[0]

    def get_micrograph(self, particle_id):
        """
        :param particle_id: Global ID of the particle
        """
        if particle_id >= self.total_particle_count or particle_id < 0:
            raise RuntimeError("ID out of bounds")
        return divmod(particle_id, self.particles_per_micrograph)

    def get_particle(self, micrograph_id, particle_id=None):
        """
        :param micrograph_id: ID of the microgram
        :param particle_id: Local ID of the particle
        """
        if micrograph_id >= self.micrograph_count or micrograph_id < 0:
            raise RuntimeError("Out of bounds for micrograph")
        if particle_id is None:
            return np.arange(
                micrograph_id * self.particles_per_micrograph,
                (micrograph_id + 1) * self.particles_per_micrograph,
            )
        if particle_id >= self.particles_per_micrograph or particle_id < 0:
            raise RuntimeError("Out of bounds for particle")
        return micrograph_id * self.particles_per_micrograph + particle_id
