import numpy as np

from aspire.image import Image
from aspire.source import Simulation
from aspire.source.image import _ImageAccessor
from aspire.utils import choice, grid_2d


class MicrographSimulation:
    def __init__(
        self,
        simulation,
        micrograph_size=4096,
        micrograph_count=1,
        particles_per_micrograph=100,
        seed=None,
        noise_adder=None,
        boundary=None,
        interparticle_distance=None,
    ):
        """
        A cryo-EM MicrographSimulation object that supplies micrographs.

        `dtype` and `particle_box_size` are inferred from `simulation`, where `dtype` is the data type of the micrographs and `particle_box_size` is the size of the particles.

        :param simulation: Simulation instance.
        :param micrograph_size: Size of micrograph in pixels, defaults to 4096.
        :param micrograph_count: Number of micrographs to generate (integer). Defaults to 1.
        :param particles_per_micrograph: The amount of particles generated for each micrograph. Defaults to 10.
        :param seed: Random seed.
        :param noise_adder: Append instance of NoiseAdder to generation pipeline.
        :param boundary: Set boundaries for particle centers, positive values move the boundary inward from the edge of the micrograph. Defaults to half of the particle size (particle_box_size // 2).
        :param interparticle_distance: Set minimum distance between particle centers, in pixels. Defaults to particle_box_size.
        :return: A MicrographSimulation object.
        """
        if not isinstance(simulation, Simulation):
            raise TypeError("Simulation should be of type Simulation.")
        self.simulation = simulation

        self.seed = seed

        self.micrograph_size = micrograph_size
        self.micrograph_count = micrograph_count

        # Check if particle count times micrograph count <= simulation.n
        if particles_per_micrograph * micrograph_count > simulation.n:
            raise ValueError(
                "The particle count times micrograph count must be less than or equal to the number of images generated by the simulation (particles_per_micrograph * micrograph_count <= simulation.n)"
            )
        if simulation.L > micrograph_size:
            raise ValueError(
                "The micrograph size must be larger or equal to the simulation's image size."
            )

        self.particle_box_size = simulation.L
        self.particles_per_micrograph = particles_per_micrograph
        self.total_particle_count = (
            self.micrograph_count * self.particles_per_micrograph
        )
        self.dtype = simulation.dtype

        self.noise_adder = noise_adder

        if boundary is None:
            self.boundary = self.particle_box_size // 2
        else:
            if (
                boundary < (-self.particle_box_size // 2)
                or boundary > self.micrograph_size // 2
            ):
                raise ValueError("Illegal boundary value.")
            self.boundary = boundary

        if interparticle_distance is None:
            self.interparticle_distance = self.particle_box_size
        else:
            self.interparticle_distance = interparticle_distance

        # Create the radial mask for each center
        g2d = grid_2d(int(2 * self.interparticle_distance), normalized=False)
        radial_mask = g2d["r"] <= self.interparticle_distance
        self.grid_x = g2d["x"].astype(int)[radial_mask]
        self.grid_y = g2d["y"].astype(int)[radial_mask]

        # Calculate the proper padding for the micrograph borders and create the micrograph mask
        self.pad = int(max(self.particle_box_size, self.interparticle_distance))
        self._mask_boundary = self.pad + self.boundary
        self._set_mask()

        # Create the centers
        self.centers = np.zeros(
            (self.micrograph_count, self.particles_per_micrograph, 2), dtype=int
        )

        # Set pass threshold here
        self._fail_limit = 0.1 * self.micrograph_count
        self._fail_count = 0
        for i in range(self.micrograph_count):
            self.centers[i] = self._create_centers(i)

        self._clean_images_accessor = _ImageAccessor(
            self._clean_images, self.micrograph_count
        )
        self._images_accessor = _ImageAccessor(self._images, self.micrograph_count)

    def _create_centers(self, micrograph_index):
        """
        Creates centers for the given micrograph if the fail threshold isn't met.

        param micrograph_index: The ID of the micrograph.
        return: A numpy array containing the generated centers.
        """
        while self._fail_count < self._fail_limit:
            try:
                self._set_mask()
                centers = np.zeros((self.particles_per_micrograph, 2))
                for i in range(self.particles_per_micrograph):
                    x, y = self._generate_center()
                    centers[i] = np.array([x, y])
                return centers
            except RuntimeError:
                self._fail_count += 1
        else:
            raise RuntimeError(
                "Micrograph generation failures exceeded limit. This can happen if constraints are too strict. Consider adjusting pass_threshold, micrograph_size, particles_per_micrograph, or interparticle_distance."
            )

    def _generate_center(self):
        """
        Helper method to generate centers using the mask.

        return: The x-y coordinate values of the generated center.
        """
        available_centers = np.transpose(np.where(self._mask))

        if available_centers.shape[0] == 0:
            self._fail_count += 1
            raise RuntimeError("Not enough centers generated.")

        random_index = choice(available_centers.shape[0], seed=self.seed)
        x, y = available_centers[random_index]
        x_vals = self.grid_x + x
        y_vals = self.grid_y + y
        self._mask[x_vals, y_vals] = False
        return x - self.pad, y - self.pad

    def _set_mask(self):
        """
        Helper method to set the mask.
        """
        self._mask = np.full(
            (
                int(self.micrograph_size + 2 * self.pad),
                int(self.micrograph_size + 2 * self.pad),
            ),
            False,
            dtype=bool,
        )
        self._mask[
            self._mask_boundary : -self._mask_boundary,
            self._mask_boundary : -self._mask_boundary,
        ] = True

    def __repr__(self):
        """
        String representation of the MicrographSimulation.

        :return: Returns a string containing the number of micrographs, dtype, and dimension.
        """
        return f"{self.micrograph_count} {self.dtype.name} micrographs of size {self.micrograph_size}x{self.micrograph_size}"

    def __len__(self):
        """
        Returns the number of micrographs.

        :return: Returns the micrograph count
        """
        return self.micrograph_count

    @property
    def clean_images(self):
        """
        Returns the micrographs without any noise.

        :return: An `ImageAccessor` for the unnoisy micrographs.
        """
        return self._clean_images_accessor

    @property
    def images(self):
        """
        Returns the micrographs with any added noise.

        return: An `ImageAccessor` for the noisy micrographs.
        """
        return self._images_accessor

    def _images(self, indices):
        """
        Accesses and returns micrographs with any added noise.

        :param indices: A 1-D NumPy array of integer indices.
        :return: An `Image` object representing the noisy micrograph.
        """
        micrographs = self._clean_images(indices)
        if self.noise_adder:
            micrographs = self.noise_adder.forward(micrographs)
        return micrographs

    def _clean_images(self, indices):
        """
        Accesses and returns micrographs without any added noise.

        :param indices: A 1-D NumPy array of integer indices.
        :return: An `Image` object representing the clean micrograph
        """
        # Initialize empty micrograph
        n_micrographs = len(indices)
        clean_micrograph = np.zeros(
            (n_micrographs, self.micrograph_size, self.micrograph_size),
            dtype=self.dtype,
        )
        # Pad the micrograph
        clean_micrograph = np.pad(
            clean_micrograph,
            ((0, 0), (self.pad, self.pad), (self.pad, self.pad)),
            "constant",
            constant_values=(0),
        )
        # Get centers
        parity = self.particle_box_size % 2
        for m in range(n_micrographs):
            global_id = indices[m]
            image = self.simulation.clean_images[self.get_particle_indices(global_id)]
            centers = self.centers[global_id]
            x_lefts = centers[:, 0] - self.particle_box_size // 2 + self.pad
            x_rights = centers[:, 0] + self.particle_box_size // 2 + parity + self.pad
            y_lefts = centers[:, 1] - self.particle_box_size // 2 + self.pad
            y_rights = centers[:, 1] + self.particle_box_size // 2 + parity + self.pad
            # Subtract image from the micrograph using the particle's bounding box and center
            for p in range(self.particles_per_micrograph):
                clean_micrograph[m][
                    x_lefts[p] : x_rights[p], y_lefts[p] : y_rights[p]
                ] = (
                    clean_micrograph[m][
                        x_lefts[p] : x_rights[p], y_lefts[p] : y_rights[p]
                    ]
                    + image[p]
                )
        clean_micrograph = clean_micrograph[
            :,
            self.pad : self.micrograph_size + self.pad,
            self.pad : self.micrograph_size + self.pad,
        ]
        return Image(clean_micrograph)

    def get_micrograph_index(self, particle_index):
        """
        Using the global ID of the particle, returns the micrograph ID and the local particle ID.

        :param particle_id: Global ID of the particle.
        :return: The micrograph ID and the local ID of the particle.
        """
        if particle_index >= self.total_particle_count or particle_index < 0:
            raise RuntimeError("Index out of bounds.")
        return divmod(particle_index, self.particles_per_micrograph)

    def get_particle_indices(self, micrograph_index, particle_index=None):
        """
        Using the micrograph ID, returns every global particle ID from that micrograph. Returns specific global IDs if the local IDs are given.

        :param micrograph_index: ID of the micrograph.
        :param particle_index: Local ID of the particle.
        :return: The global ID of the particle.
        """
        if micrograph_index >= self.micrograph_count or micrograph_index < 0:
            raise RuntimeError("Index out of bounds for micrograph.")
        if particle_index is None:
            return np.arange(
                micrograph_index * self.particles_per_micrograph,
                (micrograph_index + 1) * self.particles_per_micrograph,
            )
        if particle_index >= self.particles_per_micrograph or particle_index < 0:
            raise RuntimeError("Index out of bounds for particle.")
        return micrograph_index * self.particles_per_micrograph + particle_index
