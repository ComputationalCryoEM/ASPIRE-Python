import numpy as np

from aspire.image import Image
from aspire.source import Simulation
from aspire.source.image import _ImageAccessor
from aspire.utils import grid_2d


class MicrographSource:
    def __init__(
        self,
        simulation,
        micrograph_size=4096,
        micrograph_count=1,
        particles_per_micrograph=10,
        seed=None,
        noise_adder=None,
        boundary=None,
        interparticle_distance=None,
        pass_threshold=0.1,
    ):
        """
        A cryo-EM MicrographSource object that supplies micrographs.

         `dtype` and `particle_box_size` are inferred from `simulation`.

        :param simulation: Simulation instance.
        :param micrograph_size: Size of micrograph in pixels, defaults to 4096.
        :param micrograph_count: Number of micrographs to generate (integer). Defaults to 1.
        :param particles_per_micrograph: The amount of particles generated for each micrograph. Defaults to 10.
        :param seed: Random seed.
        :param noise_adder: Append instance of NoiseAdder to generation pipeline
        :param boundary: Set boundaries for particle centers, positive values move the boundary inward. Defaults to particle_box_size // 2.
        :param interparticle_distance: Set minimum distance between particle centers, in pixels. Defaults to particle_box_size.
        :param pass_threshold: Set the amount of micrographs that is allowed to fail and attempt a new micrographas a percent of the total micrographs. Defaults to 0.1 (10%).
        :return: A MicrographSource object.
        """
        if not isinstance(simulation, Simulation):
            raise TypeError("Simulation should be of type Simulation.")
        self.simulation = simulation

        self.seed = seed
        np.random.seed(self.seed)

        self.micrograph_size = micrograph_size
        self.micrograph_count = micrograph_count

        # Check if particle count times micrograph count <= simulation.n
        if particles_per_micrograph * micrograph_count > simulation.n:
            raise ValueError(
                "The particle count times micrograph count must be less than or equal to the number of images generated by the simulation (particles_per_micrograph * micrograph_count <= simulation.n)"
            )
        if simulation.L > micrograph_size:
            raise ValueError(
                "The micrograph size must be larger or equal to the simulation's image size."
            )

        self.particle_box_size = simulation.L
        self.particles_per_micrograph = particles_per_micrograph
        self.total_particle_count = (
            self.micrograph_count * self.particles_per_micrograph
        )
        self.dtype = simulation.dtype

        self.noise_adder = noise_adder

        if boundary is None:
            self.boundary = self.particle_box_size // 2
        else:
            if (
                boundary < (0 - self.particle_box_size // 2)
                or boundary > self.micrograph_size // 2
            ):
                raise RuntimeError("Illegal boundary value.")
            self.boundary = boundary

        if interparticle_distance is None:
            self.interparticle_distance = self.particle_box_size
        else:
            self.interparticle_distance = interparticle_distance

        # Create the radial mask for each center
        g2d = grid_2d(int(2 * self.interparticle_distance), normalized=False)
        radial_mask = g2d["r"] <= self.interparticle_distance
        self.grid_x = g2d["x"].astype(int)[radial_mask]
        self.grid_y = g2d["y"].astype(int)[radial_mask]

        # Calculate the proper padding and create the mask
        self.pad = int(max(self.particle_box_size, self.interparticle_distance))
        self._mask = np.full(
            (
                int(self.micrograph_size + 2 * self.pad),
                int(self.micrograph_size + 2 * self.pad),
            ),
            False,
            dtype=bool,
        )
        self._mask_boundary = self.pad + self.boundary
        self._mask[
            self._mask_boundary : -1 * self._mask_boundary,
            self._mask_boundary : -1 * self._mask_boundary,
        ] = True

        # Create the centers
        self.centers = np.zeros(
            (self.micrograph_count, self.particles_per_micrograph, 2), dtype=int
        )
        self._fail_limit = pass_threshold * self.micrograph_count
        self._fail_count = 0
        for i in range(self.micrograph_count):
            self.centers[i] = self._create_centers(i)

        self._clean_micrographs_accessor = _ImageAccessor(
            self._clean_micrographs, self.micrograph_count
        )
        self._micrographs_accessor = _ImageAccessor(
            self._micrographs, self.micrograph_count
        )

        self.images = _ImageAccessor(self._images, self.total_particle_count)

    def _create_centers(self, micrograph):
        """
        Creates centers for the given micrograph if the fail threshold isn't met.

        param micrograph: The ID of the micrograph.
        return: A numpy array containing the generated centers.
        """
        while self._fail_count < self._fail_limit:
            try:
                self._reset_mask()
                centers = np.zeros((self.particles_per_micrograph, 2))
                for i in range(self.particles_per_micrograph):
                    x, y = self._generate_center(micrograph)
                    centers[i] = np.array([x, y])
                return centers
            except RuntimeError:
                self._fail_count += 1
        else:
            raise RuntimeError(
                "Micrograph generation failures exceeded limit. This can happen if constraints are too strict. Consider adjusting pass_threshold, micrograph_size, particle_count, or interparticle_distance."
            )

    def _generate_center(self, micrograph):
        """
        Helper method to generate centers using the mask.

        param micrograph: The ID of the micrograph.
        return: The x-y coordinate values of the generated center.
        """
        available_centers = np.transpose(np.where(self._mask))

        # Reset mask and raise errors if there aren't any valid centers
        if available_centers.shape[0] == 0:
            self._fail_count += 1
            raise RuntimeError("Not enough centers generated.")

        random_index = np.random.choice(available_centers.shape[0])
        x, y = available_centers[random_index]
        x_vals = self.grid_x + x
        y_vals = self.grid_y + y
        self._mask[x_vals, y_vals] = False
        return x - self.pad, y - self.pad

    def _reset_mask(self):
        """
        Helper method to reset the mask.
        """
        self._mask = np.full(
            (
                int(self.micrograph_size + 2 * self.pad),
                int(self.micrograph_size + 2 * self.pad),
            ),
            False,
            dtype=bool,
        )
        self._mask[
            self._mask_boundary : -1 * self._mask_boundary,
            self._mask_boundary : -1 * self._mask_boundary,
        ] = True

    def __repr__(self):
        """
        String representation of the MicrographSource.
        """
        return f"{self.micrograph_count} {self.dtype.name} micrographs of size {self.micrograph_size}x{self.micrograph_size}"

    def __len__(self):
        """
        Returns the number of micrographs.
        """
        return self.micrograph_count

    @property
    def clean_micrographs(self):
        """
        Returns the micrographs without any noise.
        """
        return self._clean_micrographs_accessor

    @property
    def micrographs(self):
        """
        Returns the micrographs with any added noise.
        """
        return self._micrographs_accessor

    def _micrographs(self, indices):
        """
        Accesses and returns micrographs with any added noise.
        :param indices: A 1-D NumPy array of integer indices.
        :return: An `Image` object representing the clean micrograph.
        """
        micrographs = self._clean_micrographs(indices)
        if self.noise_adder:
            micrographs = self.noise_adder.forward(micrographs)
        return micrographs

    def _clean_micrographs(self, indices):
        """
        Accesses and returns micrographs without any added noise.

        :param indices: A 1-D NumPy array of integer indices.
        :return: An `Image` object representing the clean micrograph
        """
        # Initialize empty micrograph
        n_micrographs = len(indices)
        clean_micrograph = np.zeros(
            (n_micrographs, self.micrograph_size, self.micrograph_size),
            dtype=self.dtype,
        )
        # Pad the micrograph
        clean_micrograph = np.pad(
            clean_micrograph,
            ((0, 0), (self.pad, self.pad), (self.pad, self.pad)),
            "constant",
            constant_values=(0),
        )
        # Get centers
        parity = self.particle_box_size % 2
        for m in range(n_micrographs):
            global_id = indices[m]
            image = self.simulation.clean_images[self.get_particle(global_id)]
            centers = self.centers[global_id]
            x_lefts = centers[:, 0] - self.particle_box_size // 2 + self.pad
            x_rights = centers[:, 0] + self.particle_box_size // 2 + parity + self.pad
            y_lefts = centers[:, 1] - self.particle_box_size // 2 + self.pad
            y_rights = centers[:, 1] + self.particle_box_size // 2 + parity + self.pad
            # Subtract image from the micrograph using the particle's bounding box and center
            for p in range(self.particles_per_micrograph):
                clean_micrograph[m][
                    x_lefts[p] : x_rights[p], y_lefts[p] : y_rights[p]
                ] = (
                    clean_micrograph[m][
                        x_lefts[p] : x_rights[p], y_lefts[p] : y_rights[p]
                    ]
                    - image[p]
                )
            # Normalize micrographs
            min_value = np.abs(np.min(clean_micrograph[m]))
            clean_micrograph[m] = clean_micrograph[m] + min_value
        clean_micrograph = clean_micrograph[
            :,
            self.pad : self.micrograph_size + self.pad,
            self.pad : self.micrograph_size + self.pad,
        ]
        return Image(clean_micrograph)

    def _images(self, indices):
        """
        Accesses and returns the projections from the Simulation.

        :param indices: A 1-D NumPy array of integer indices.
        :return: An `Image` object.
        """
        return self.simulation.images[indices]

    def get_micrograph(self, particle_id):
        """
        Using the global ID of the particle, returns the micrograph ID and the local particle ID.

        :param particle_id: Global ID of the particle.
        :return: The micrograph ID and the local ID of the particle.
        """
        if particle_id >= self.total_particle_count or particle_id < 0:
            raise RuntimeError("ID out of bounds.")
        return divmod(particle_id, self.particles_per_micrograph)

    def get_particle(self, micrograph_id, particle_id=None):
        """
        Using the micrograph ID, returns every global particle ID from that micrograph. Returns specific global IDs if the local IDs are given.

        :param micrograph_id: ID of the microgram.
        :param particle_id: Local ID of the particle.
        :return: The global ID of the particle.
        """
        if micrograph_id >= self.micrograph_count or micrograph_id < 0:
            raise RuntimeError("Out of bounds for micrograph.")
        if particle_id is None:
            return np.arange(
                micrograph_id * self.particles_per_micrograph,
                (micrograph_id + 1) * self.particles_per_micrograph,
            )
        if particle_id >= self.particles_per_micrograph or particle_id < 0:
            raise RuntimeError("Out of bounds for particle.")
        return micrograph_id * self.particles_per_micrograph + particle_id
